# 1. 연관관계

- 회원과 팀
- 회원은 하나의 팀에만 소속될수 있다
- 팀에는 많은 회원이 있을수 있다.

## 객체 테이블에 맞춘 모델링

**연관관계가 필요한 이유..**

![image](https://user-images.githubusercontent.com/57162257/120189459-5723c180-c252-11eb-8cbf-ad79b5ef7759.png)

```java
@Entity
public class Member{
    @Id
    @GeneratedValue
    private Long id;
    
    @Column(name = "USERNAME")
    private String name;
    
    @Column(name = "TEAM_ID")
    private Long id;
}

@Entity
public class Team{
    @Id
    @GeneratedValue
    private Long id;
    
    @Column(name = "TEAM_NAME")
    private String name;
}
```

```java
//팀 저장
Team team = new Team();
team.setName("Chelsea");
em.persist(team);

//회원 저장
Member member = new Member();
member.setName("Kane");
member.setTeamId(team.getId());
em.persist(member);
```

```java
//회원의 팀 찾기
Member findMember = em.find(Member.class, member.getId());

Long findTeamId = findMember.getId();
Team findTeam = em.find(Team.class, findTeamId);
```

- 위의 코드들은 연관관계 없이 그저 식별값을 통해서 거치고 거쳐서 찾아서 많은 비용이 소모됨
- **객체 지향스럽지 못한 코드**
- 객체를 테이블에 맞춰 데이터 중심으로 모델링하면, 협력관계를 위 코드처럼 만들 수 없다
  - 테이블은 **외래 키 조인**을 통해 연관된 테이블을 찾음
  - 객체는 **객체 참조**를 사용해서 연관된 객체를 찾음



# 2. 단방향 연관관계

![image](https://user-images.githubusercontent.com/57162257/120190440-8f77cf80-c253-11eb-80fa-1a9a528cf933.png)

## 객체 연관관계

- Member엔티티에는 Member.team 필드로 Team엔티티와 연관관계를 맺음
- 회원 객체와 팀 객체는 단방향 관계
  - 회원은 Member.team을 통해 팀을 알수 있다
  - 팀은 소속 회원을 알수 없다.

## 테이블 연관관계

- Member테이블은 Team테이블의 id값을 외래키로 연관관계를 맺음
- 회원 테이블과 팀 테이블은 양방향 관계
  - 회원과 팀 테이블은 `MEMBER JOIN TEAM `또는 `TEAM JOIN MEMBER`로 서로 연관되는 테이블의 값을 가져올수 있다.

즉, **테이블 연관관계는 외래키를 하나만 설정해줘도 양방향이 가능. 하지만 참조를 통한 객체 연관관계는 항상 단방향.**

# 3. 다대일

-**엔티티 선언**

```java
@Entity
public class Member{
    @Id @GeneratedValue
    private Long id;
    
    @Column(name = "USERNAME")
    private String name;
    
    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team;
}

@Entity
public class Team{
    @Id @GeneratedValue
    private Long id;
    
    @Column(name = "TEAM_NAME")
    private String name;
}
```

-**연관관계 저장**

```java
//팀 저장
Team team = new Team();
team.setName("Chelsea");
em.persist(team);

//회원 저장
Member member = new Member(); 
member.setName("Kane");
member.setTeam(team); //단방향 연관관계 설정, 참조 저장 
em.persist(member);
```

-**참조로 연관관계 조회 - 객체 그래프 탐색**

```java
//조회
Member findMember = em.find(Member.class, member.getId());
//참조를 사용해서 연관관계 조회
Team findTeam = findMember.getTeam();
```

-**연관관계 수정**

```java
// 새로운 팀B
Team teamB = new Team();
teamB.setName("MU");
em.persist(teamB);

// 회원1에 새로운 팀B 설정
member.setTeam(teamB);
```



### @ManyToOne

- 다대일 관계의 매핑 정보
- 팀은 다수의 회원을 가질수 있다.
- 속성
  - **fetch** : 패치 전략
    - **Eager** : 해당 엔티티를 조회할때 연관관계에 있는 엔티티도 함께 가져온다. 
    - **Lazy** : 해당 엔티티를 조회할때 엔티티를 조회할 때 그제서야 가져온다.
  - **cascade** : 영속성 전이 기능을 사용
  - targetEntity : 연관된 엔티티의 타입 정보를 설정(사용x)
  - optional : false로 설정하면 연관된 엔티티가 항상 있어야한다.

### @JoinColumn

- 외래키를 매핑할 때 사용
- 속성
  - **name** : 매핑할 외래 키 이름("필드명"+_+"참조 테이블 기본키")
  - referencedColumnName : 외래 키가 참조하는 대상 테이블의 컬럼명
  - freignKey(DDL) : 외래 키 제약조건을 직접 지정할수있다, 테이블을 생성할 때만 사용



# 4.양방향 연관관계

![image](https://user-images.githubusercontent.com/57162257/120197029-8559cf00-c25b-11eb-828b-064cba96bf13.png)

## 객체 연관관계

- Member엔티티에서 Member.team필드를 통해 연관관계를 맺음
  - Member.team을 통해 Team을 찾을수 있다
- Team엔티티에서 Team.members.get()를 통해 소속된 Member를 찾을수 있다.
- 서로 연관된 엔티티에서 서로를 찾을수 있음으로 양방향 연관관계



![image](https://user-images.githubusercontent.com/57162257/120197203-af12f600-c25b-11eb-9898-6341f3fed8a8.png)

## 테이블 연관관계

- 두 테이블 다 `JOIN`을 통해 서로를 찾을수 있다.
- 데이터베이스 테이블은 외래 키 하나로 양방향으로 조회할수 있다.



## 양방향 연관관계 매핑

-**엔티티 선언**

```java

```

-**일대다 컬렉션 조회**

```java

```



# 5.연관관계 주인