# 1.라이브러리 의존관계

gradle이나 maven같은 빌드 툴들은 의존관계를 관리해줌.
ex) spring-boot-starter-web라이브러리를 가져오면 서로 필요한 라이브러리를 함꼐 땡겨서 가져온다.

- Gradle - Dependencies
  - complieClasspath에 있는 주요 라이브러리와 관련된 라이브러리를 확인해보면 되게 많은 라이브러리들이 있는데 그런것들을 주요 라이브러리를 선택하면 그것과 관련있는 라이브러리를 maven 툴들이 함께 가져오게한것
- 주요 라이브러리
  - spring-boot-starter-web
    - spring-boot-starter-tomcat : 톰캣
    - spring-webmvc : 스프링 웹 mvc
  - spring-boot-starter-thymeleaf : 타임리프 템플릿 엔진(view)
  - spring-boot-starter(공통) : 스프링 부트 + 스프링 코어 + 로깅
    - spring-boot
      - spring-core
    - spring-boot-starter-loggin
      - logback, slf4j
  - spring-boot-starter-test: 테스트 라이브러리
    - junit : 테스트 프레임워크
    - mockito : 목 라이브러리
    - assertj : 테스트 코드를 편리하게 작성하게 도와주는 라이브러리
    - spring-test : 스프링 통합 테스트 지원



# 2.View환경설정

## (1) view 반환

```java
@Controller
public class HelloController{
    @GetMapping("hello") 
    public String hello(Model model){
        model.addAttribute("data","hello!!");
        return "hello";
    }
}
```

```html
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Hello</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>
<body>
<p th:text="'안녕하세요. ' + ${data}" >안녕하세요. 손님</p>
</body>
</html>
```

url로 `/hello` 경로로 요청을 보내게도면 `templates`의 `hello.html`이 출력된다.

**``controller``**

- `GetMapping` : url 메소드
- `model.addAttribute` : html파일에 보낼 속성 명과 속성값
  model.addAttrubte([속성명],[속성값])
- `return` : 반환하는 값이 html파일명인 것을 반환.

**``hello.html``**

- data : 속성값이 data인 값을 controller에서 받아와서 출력

## (2) 동작 환경

![image](https://user-images.githubusercontent.com/57162257/116716840-2eba6480-aa13-11eb-9b44-19163bf38827.png)

- 컨트롤러에서 리턴 값으로 문자를 반환하면 viewResolver가 화면을 찾아서 처리한다.
  - SpringBoot 템플릿엔진 기본 viewName매핑
  - `resources: templates/` + {viewName} + `.html`

# 3.Build하기(linux)

1. 프로젝트 루트 디렉터리 이동
2. gradlew디렉터리 확인후 ./gradlew build
3. cd build/libs
4. java -jar {프로젝트이름}-0.0.1-SNAPSHOT.jar
5. 실행 확인

ec2와 같은 서버에 빌드된 파일을 배포하고 java -jar 명령어로 빌드파일을 실행만해주면 된다.

그 이유는 ``빌드된 JAR파일안에 내장된 웹서버(기본은 톰캣)를 내포하고있고, 실제 JAR파일을 실행하면 내장된 웹서버가 동작된다.``

``또한 SpringBoot로 프로젝트를 생성하면 spring-boot-starter-web패키지 의존성이 있는데 해당 패키지는 spring-boot-starter-tomcat패키지를 내포한다. 그렇기에 따로 복잡한 설정을 해주지 않아도 서버를 편리하게 배포해줄수 있게 된다.``

만약 빌드가 실패한다면 루트 디렉터리로 이동한후 ``./gradlew clean build`` 명령어를 수행해주면 build파일의 빌드 파일을 삭제후 다시 빌드한다.



# 4.스프링 웹 개발 기초



## (1)정적컨텐츠

[기본]
![image](https://user-images.githubusercontent.com/57162257/116722684-aee3c880-aa19-11eb-9366-d929ee96e988.png)

[Spring Boot]![image](https://user-images.githubusercontent.com/57162257/116723977-0afb1c80-aa1b-11eb-9ca7-d4709eecc331.png)

그냥 파일을 클라이언트에게 반환해주는것. 오직 웹서버만 사용해서 정적파일을 반환해주는 경우.

localhost:{포트번호}/{정적파일}은 정적파일을 불러올수 있음.

이런걸 URL(Uniform Resource Locator, 파일 식별자)

## (2)MVC와 템플릿 엔진

### 동적 컨텐츠

![image](https://user-images.githubusercontent.com/57162257/116722723-bc994e00-aa19-11eb-83b5-9ef984dda3ca.png)

![image](https://user-images.githubusercontent.com/57162257/116724992-4fd38300-aa1c-11eb-8915-5b3db1e9b854.png)

이런걸 URI(Uniform Resource Identifier, 인터넷 자원을 나타내는 주소)

-------------------------

### MVC

- Model : view에서관련된 것들을 담아서 view로 전달
- View : 화면과 관련된 일(.html)
- Controller : 요청과 관련된 비즈니스 로직 처리 및 반환



## (3)API

![image](https://user-images.githubusercontent.com/57162257/116727370-6e874900-aa1f-11eb-8375-b354fd8da64e.png)

파일을 보내주는 형식이 아닌 데이터를 반환해주는 방법

``@RestController`` 어노테이션을 사용하여 데이터를 반환해준다. `@Controller` 어노테이션을 사용한다면 `@ResponseBody`어노테이션이 필요하지만` @RestController` 어노테이션은 `@Controller+@RespopnseBody`를 합친거라 따로 선언해줄필요없다.

- HTTP의 Body에 문자 내용을 직접반환
- `viewResolver`대신에 `HttpMessageConverter`동작
- 기본 문자처리 : `StringHttpMessageConverter`
- 기본 객체처리 : `MappingJackSon2HttpMessageConverter`
- Jackson : 객체를 json으로 변경해주는 라이브러리

객체 자체를 반환해준다면 json타입으로 보내준다.

![image](https://user-images.githubusercontent.com/57162257/116727228-3c75e700-aa1f-11eb-89ce-fa4cba6b4793.png)

![image](https://user-images.githubusercontent.com/57162257/116727284-4ef02080-aa1f-11eb-851e-5849a900e9b5.png)



# 5. 회원 관리 예제

## 비즈니스 요구사항

- 데이터 : 회원ID, 이름
- 기능 : 회원 등록, 조회
- 저장소 : 가상의 시나리오

## 웹 애플리케이션 계층 구조

![image](https://user-images.githubusercontent.com/57162257/116771124-f141ef80-aa83-11eb-86af-d94732d57533.png)

- 컨트롤러 : 웹 MVC의 컨트롤러 역할
- 서비스 : 핵심 비즈니스 로직 구현
- 레포지토리 : 데이터베이스에 접근, 도메인 객체를 DB에 저장하고 관리
- 도메인 : 비즈니스 도메인 객체

## 클래스 의존 관계

![image](https://user-images.githubusercontent.com/57162257/116771176-5990d100-aa84-11eb-94bc-a68d72696f4f.png)

- 회원 레포지토리는 아직 저장소가 정해지지 않았기 때문에 **인터페이스로 구현**



## (1) Domain구현

[domain/Member.java]

```java
public class Member{
    private Long id;
    private String name;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName(){
        return name;
    }
}
```



## (2) Repository구현

[repository/MemberRepository.java]

```java
public interface MemberRepository{
    Member save(Member member);
    Optional<Member> findById(Long id);	//null을 포함할수 있는 클래스
    Optional<Member> findByName(String name);
    List<Member> findAll();
}
```

[repository/MemoryMemberRepository.java]

```java
public class MemoryMemberRepository implements MemberRepository{
    private static Map<Long,Member> store = new HashMap<>();
    private static long sequence = 0L;

    @Override
    public Member save(Member member) {
        member.setId(++sequence);
        store.put(member.getId(), member);
        return member;
    }

    @Override
    public Optional<Member> findById(Long id) {
        return Optional.ofNullable(store.get(id));	//.ofNullalbe메소드는 null을 포함할수 있음
    }

    @Override
    public Optional<Member> findByName(String name) {
        return store.values().stream()
                .filter(member -> member.getName().equals(name))    //store에서 받은 각 객체마다 돌리면서 name과 같은 이름을 필터링
                .findAny(); //Map에서 찾으면서 하나라도 있으면 그걸 반환, 없다면 Optional에 null이 포함되서 반환
    }

    @Override
    public List<Member> findAll() {
        return new ArrayList<>(store.values());
    }
}
```

### 꿀팁

인터페이스 명을 작성하고 `alt+Enter`하면 `Override`함수가 자동으로 생성됨.



## (3)Repository 테스트 케이스 작성

테스트케이스는 main디렉토리에 있는 테스트하고자하는 클래스의 위치와 동일하게 하고 이름도 뒤에 Test만 추가해준다.

[repository/MemoryMemberRepository.java]

```java
public class MemoryMemberRepositoryTest {
    MemoryMemberRepository repository = new MemoryMemberRepository();

    @AfterEach //각 테스트 케이스가 수행된후 실행, 각 테스트간 의존관계를 없애기 위해 꼭 필요한 작업
    public void afterEach(){
        repository.clearStore();
    }

    @Test
    public void save(){
        Member member = new Member();
        member.setName("spring");
        repository.save(member);

        Member result = repository.findById(member.getId()).get();
        assertThat(member).isEqualTo(result);
    }

    @Test
    public void findByName(){
        Member member1 = new Member();
        member1.setName("spring1");
        repository.save(member1);

        Member member2 = new Member();//shift f6 : 이름 한꺼번에 여러개 바꾸기
        member2.setName("spring2");
        repository.save(member2);

        Member result = repository.findByName("spring1").get();

        assertThat(result).isEqualTo(member1);
    }

    @Test
    public void findAll(){
        Member member1 = new Member();
        member1.setName("spring1");
        repository.save(member1);

        Member member2 = new Member();
        member2.setName("spring2");
        repository.save(member2);

        List<Member> result = repository.findAll();

        assertThat(result.size()).isEqualTo(2);
    }
}
```

김영한님은 `assertj.core.api.Assertions`를 주로 사용하신다고 했다.

### 꿀팁

- `@Test`어노테이션을 테스트 케이스위에 작성해주어야 Junit에서 테스트임을 인지할수있다.
- `Optional< Member >`로 반환되는 메소드에서 `.get()`등의 메소드를 사용해주면 Optional을 벗겨주고 반환해주므로 Member meber객체로 받을수 있다.
- `@AfterEach`으로 store를 테스트마다 비워주지 않는다면 전 테스트에 사용됬던 객체들이 사용될수 있으니 꼭! 고려하자
- `assertThat()`메소드를 사용할때 `alt+enter`를 통해 static으로 고정시켜놓으면 바로 사용할수있다.
- `shift+f6`은 한 블록에 있는 같은 이름을 동시에 변경할수 있다.



## (4)Service구현

Repository는 개발에 초점을 두었다면 Service는 비즈니스적 언어에 초점을 맞춰야한다.

[MemberService.java]

```java
public class MemberService {
    private final MemberRepository memberRepository= new MemoryMemberRepository();

    //회원가입
    public Long join(Member member){
        //중복회원 검증
        validateDuplicateMember(member); 

        memberRepository.save(member);
        return member.getId();
    }

    private void validateDuplicateMember(Member member) {
        memberRepository.findByName(member.getName()) 
                .ifPresent(m -> {   
                    throw new IllegalStateException("이미 존재하는 회원입니다.");
                });
    }

    //전체회원 조회
    public List<Member> findMembers(){
         return memberRepository.findAll();

    }
}
```

- `.isPresent()` : Optional객체가 감싸고 있는 값이 존재할 경우에만 실행하는 메소드

### 꿀팁

- 레포지토리에서 데이터를 가져왔을때 `member.getName()`등으로 직접 가져오는것은 좋지못하다.
- `ctrl+alt+m` : 로직은 메소드화(Extract Method)
- `ctrl+alt+v` : 반환되는 타입에 맞게 변수를 만들어줌



## (5)Service 테스트케이스 작성

```java
class MemberServiceTest {

    MemberService memberService;
    MemoryMemberRepository memberRepository;

    @BeforeEach
    public void DI(){
        memberRepository = new MemoryMemberRepository();
        memberService = new MemberService(memberRepository);
    }

    @AfterEach
    public void clearUp(){
        memberRepository.clearStore();
    }

    @Test
    @DisplayName("회원가입")
    void join() {
        //given
        Member member = new Member();
        member.setName("spring");

        //when
        Long saveId = memberService.join(member);

        //then
        Member member1 = memberRepository.findById(saveId).get();
        assertThat(member1).isEqualTo(member);
    }

    @Test
    @DisplayName("중복_회원_예외")
    public void join_exception(){
        //given
        Member member1 = new Member();
        member1.setName("spring");

        Member member2 = new Member();
        member2.setName("spring");

        //when
        memberService.join(member1);
        IllegalStateException e = assertThrows(IllegalStateException.class, () -> memberService.join(member2));

        //then
        assertThat(e.getMessage()).isEqualTo("이미 존재하는 회원입니다.");
    }

    @Test
    @DisplayName("회원 전체 출력")
    void findMembers() {
    }
}
```

- 테스트 케이스 작성시 **예외(Exception)**에 대한 테스트 케이스를 작성하지 않는다면 반쪽짜리 테스트 케이스
- 테스트 케이스를 작성할때 기본적으로 **given(초기설정)** ,**when(기능 수행)** ,**then(결과)**으로 작성
- `assertThrows(예외클래스,()-> 기능수행)` : 기능수행을 했을때 예외가 발생하면 **success**, 발생하지 않는다면 **fail**
- `assertThrows`도 예외클래스 타입으로 반환되므로 반환 타입을 통해 예외 메시지를 `getMessage()`를 통해 확인할수 있다.

### 꿀팁

- `ctrl+shift+T` : 해당 위치에 맞는 테스트 케이스 자동 생성
- `MemberService`와 `MemorymemberRepository`는 서로 의존관계이다. 하지만 Service에 `new MemorymemberRepository`가 있고 ServiceTest에서 `new MemorymemberRepository`로 생성한다면 서로 다른 레퍼지토리를 사용하는것이기 때문에 에러 발생확률이 높아진다. 그렇기 때문에 Service생성자 사용시 Repository의 **의존성을 주입(DI)**해준다.
  `@BeforEach`를 통해 각 테스트마다 Service에 Repository 의존성을 주입해준다.
  나중에는 `@RequireConstructArgs`어노테이션을 통해 간편하게 의존성 주입을 할수 있다.